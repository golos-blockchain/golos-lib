# Шифрование постов (cryptor)

### Шифрование поста

Метод следует вызывать перед отправкой операции `comment`. Затем подставлять зашифрованный текст в операцию `comment`

Авторизация не требуется.

```js
async function test() {
    let res
    try {
        res = await golos.api.encryptBodyAsync({
            author: 'alice',
            body: 'Текст поста'
        })
    } catch (err) {
        console.error(err)
        return
    }
    console.log(res)
}

test()
```

Поля ответа:
- `status` - `"ok"` или `"err"`.
- `encrypted` - зашифрованный пост в виде base64-строки.
- `error` - `"unavailable_no_key_in_config"`, если данная нода не подходит для шифровки поста, или `"unknown"` в случае какой-то иной ошибки.

После того, как пост зашифрован, следует подставить следующее значение как `body` в операцию `comment`:
```js
JSON.stringify({t: 'e', v: 2, c: res.encrypted})
```

`t` указывает, что пост зашифрован, `v` - версия шифрования (1, если пост шифруется с помощью Golos Auth Service; в данном случае - 2 - пост шифруется блокчейном).

### Расшифровка поста

Для расшифровки поста требуется **авторизация**, чтобы доступ к посту имел только автор, либо тот, кто стал спонсором автора, либо тот, кто оплатил `decrypt_fee`, а другие пользователи не могли расшифровать пост от имени автора или спонсора.

- Получить `head_block_number` и `witness` этого блока. Они должны быть не старше 10-30 сек.
- `head_block_number` преобразовать в строку и с помощью `signData()` подписать ее приватным posting-ключом того аккаунта, от имени которого производится расшифровка.
- добавить подпись (в виде HEX-строки) и `witness` в запрос, как показано в примере ниже.

```js
async function test() {
    const { head_block_number, witness } = await golos.api.getDynamicGlobalPropertiesAsync()

    const signed = golos.auth.signData(head_block_number.toString(), {
        posting: '5HwQScueMZdELZpjVBD4gm6xhiKiMqGx18g4WtQ6wVr4nBdSxY5'
    })

    let res
    try {
        res = await golos.api.decryptCommentsAsync({
            account: 'alice', // обладатель posting-ключа
            signed_data:  {
                head_block_number,
                witness,
            },
            signature: signed.posting,
            entries: [{ // одним запросом можно расшифровать сразу много постов, и если какой-то из них расшифровать не удастся, то не сорвется весь запрос
                author: 'bob',
                permlink // или hashlink, или body
            }]
        })
    } catch (err) {
        console.error(err)
        return
    }
    console.log(res)
}

test()
```

Поля ответа:
- `status` - `"ok"` или `"err"`.
- `error` - ошибка запроса в целом (а не ошибки расшифровки отдельных постов. Если не получается расшифровать отдельные посты, то остальные посты все равно будут расшифрованы и статус будет `ok`).
- `results` - результаты расшифровки каждого поста, в том же порядке, что и `entries`.

Ошибки, при которых запрос сорвется целиком:
- `"head_block_num_in_future"`- такого блока еще не существует.
- `"head_block_num_too_old"` - слишком старый блок, больше 30-60 сек. назад. Старые блоки не принимаются, чтобы нельзя было единожды украсть\подделать подпись и в дальнейшем всегда расшифровывать ею посты.
- `"account_not_exists"` - нет такого аккаунта.
- `"illformed_signature"` - неверный формат подписи, т.е. она вообще не является корректной подписью или отсутствует.
- `"wrong_signature"` - формат подписи корректный, но она сделана не актуальным posting-ключом аккаунта, а каким-то другим. 

В случае `ok`, каждый из `results` содержит поля:
- `author` - автор поста.
- `body` - расшифрованный текст поста, если расшифровать пост получилось.
- `err` - ошибка расшифровки, если не получилось. Возможные значения: `wrong_json_or_not_encrypted` (пост вообще не зашифрован или его body некорректно), `not_encrypted` (не зашифрован или зашифрован версией 1, которая шифруется не плагином cryptor, а с помощью Golos Auth Service), `cannot_decrypt`, `inactive` (спонсорство истекло), `no_sponsor`, `no_sub` (автор удалил спонсорскую подписку). 
- `sub` - параметры платной подписки автора (ее цена), если пост не удалось расшифровать и подписка существует.
- `decrypt_fee` - если расшифровку поста можно оплатить разово, то сколько оплатить.

### Шифрование и расшифровка абстрактных данных. Альтернативные применения cryptor

Уже в первой версии плагин теоретически позволяет шифровать не только посты, но и любые другие данные и использовать это в ваших сервисах на основе Golos.  
В запросе на расшифровку в этом случае вместо `permlink\hashlink` используйте `body`, в который передавайте саму шифровку.  
Расшифровать шифровку пока что может только автор или спонсор автора.
