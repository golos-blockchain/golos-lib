## Модуль на WebAssembly

golos-lib-js архитектурно является оберткой для golos-lib, которая написана на Rust и скомпилирована в WebAssembly. Впрочем, большинство функций и классов библиотеки golos-lib-js пока что не используют этот модуль.  
Функции, которым требуется модуль WebAssembly, в данной документации обозначены иконкой :electron:.

Если вы используете в своем проекте такие функции, то на момент их вызова должен быть импортирован модуль WebAssembly:
```js
await golos.importNativeLib();
```
Или так:
```js
golos.importNativeLib().then(() => {
    // и здесь должен быть ВЕСЬ код, который использует WebAssembly
});
```

Этот вызов занимает относительно мало времени (от 20 до 100 мсек), поэтому пользователю неудобств он не доставит.

Например, в React вы можете вызвать `importNativeLib` одним из двух способов:
- один раз перед клиентским рендерингом всего приложения. Не забудьте вызвать также на сервере, если используете SSR;
- в конструкторе отдельного компонента. Но конструктор не может быть асинхронным, поэтому везде, где используете функции (в `render()`, в обработчиках событий), сперва проверяйке состояние загрузки с помощью `golos.isNativeLibLoaded()`, чтобы исключить слишком ранний вызов функций. (На практике маловероятно, что пользователь успеет, скажем, нажать какую-то кнопку, до того, как модуль импортируется.) В случае с `render()` также нужно вызвать `setState` после импорта, чтобы гарантированно произошел ре-рендер, и `render()` в этот раз уже смог воспользоваться функциями.

Только для `golos.utils.Asset`: если используете только эту функцию, то вы можете просто всегда вызывать ее с `await`, и тогда она сама импортирует модуль, если этого еще не сделано.
```js
const asset = await golos.utils.Asset('1.000 GOLOS');
console.log(asset.toString(0));

console.log((await golos.utils.Asset('1.000 GOLOS')).toString(0)); // обратите внимание, где стоят скобки
```

Остальные функции, использующие WebAssembly, при неимпортированном модуле будут выбрасывать ошибку с соответствующим текстом.
